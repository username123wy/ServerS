<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="servers">ServerS</h1>
<h4 id="author--yi-wu">Author : Yi Wu</h4>
<h4 id="e-mail--yiwunuaaeducn">E-mail : yiwu@nuaa.edu.cn</h4>
<h2 id="1%E4%BB%8B%E7%BB%8D">1.介绍</h2>
<p>通过HTTP服务编写一个API server。支持通过简单的命令实现对csv数据表的查询操作。项目GIT:
<a href="https://github.com/username123wy/ServerS">https://github.com/username123wy/ServerS</a></p>
<h2 id="2%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90">2.可行性分析</h2>
<p>实现一个小型的csv数据库，通过命令行操作，数据文件只针对csv文件，并通过HTTP服务访问。选用java实现。</p>
<ul>
<li>csv存储数据：java有很多支持csv文件操作的工具。</li>
<li>命令行解析：题目要求的命令较为简单，基本的字符串解析处理，编译原理课程基础。同时java有很多词法分析，语法分析生成器，可以自动根据语法生成编译前端，自动生成关于命令的抽象语法树。</li>
<li>HTTP服务访问：java支持通过套接字编程实现基本的HTTP服务。</li>
</ul>
<p>综上，初步分析，项目可行。</p>
<h2 id="2%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90">2.需求分析</h2>
<p>首先，整个项目主要分为三个部分的需求：1) 通过HTTP访问。2) 通过命令操作。3) 根据命令内容操作csv数据表。</p>
<h3 id="21-%E9%80%9A%E8%BF%87http%E8%AE%BF%E9%97%AEhttp-server">2.1 通过HTTP访问(HTTP-Server)</h3>
<p>以题目的基本要求为主，通过HTTP服务获取命令，并执行命令，并将命令执行结果通过HTTP服务返回。</p>
<h3 id="22-%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9Ccmd-control">2.2 通过命令操作(CMD-Control)</h3>
<p>通过命令操作，从HTTP服务处获取用户命令，解析命令，根据命令内容进行csv文件操作。题目的基本要求为查询操作。</p>
<h3 id="23-%E6%93%8D%E4%BD%9Ccsv%E6%96%87%E4%BB%B6csv-manager">2.3 操作csv文件(CSV-Manager)</h3>
<p>能够读取csv文件并支持基本的增，删，改，查功能，题目的主要要求以读取为主。</p>
<h2 id="3%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0">3.项目设计与实现</h2>
<h3 id="31-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">3.1 项目结构设计</h3>
<p>ServerS主要结构如图N所示：</p>
<p><img src="./images/SS_Structure.png" alt="SS_Structure"></p>
<p>首先，ServerS通过<code>Http Server</code>获取到从客户端发送的<code>命令文本</code>，并将<code>命令文本</code>的内容传递到命令解析器<code>SSActioner</code>中进行解析，获取到命令对应的实例化对象(<code>命令实例</code>)。将<code>命令实例</code>作为输入，通过查询命令管理器<code>QueryManager</code>，进行命令内容的查询。命令查询管理器<code>QueryManager</code>根据<code>命令实例</code>的内容调用数据文件加载器<code>FileHandler</code>，获取对应的数据内容，并将数据内容返回给查询命令管理器<code>QueryManager</code>，在查询命令管理器<code>QueryManager</code>中将数据内容进行计算，并将最终计算结果通过<code>Http Server</code>返还给客户端。</p>
<h3 id="31-http-server">3.1 HTTP Server</h3>
<p>HTTP Server模块的主要结构如下图所示：</p>
<p><img src="./images/SS_Structure_http.png" alt="Http_Server"></p>
<p>使用java内置的套接字接口实现从HTTP服务中获取命令。绑定端口为localhost:8800，主要操作代码如下：</p>
<pre class="hljs"><code><div>//1.建立一个服务器Socket(ServerSocket)绑定指定端口
ServerSocket serverSocket=new ServerSocket(8800);
//2.使用accept()方法阻止等待监听，获得新连接
Socket socket=serverSocket.accept();
....
</div></code></pre>
<p><strong>完整代码将在附录1中给出，代码对应位置</strong><code>ServerS\src\main\java\cn\edu\nuaa\little1\http\HttpServer.java</code></p>
<h3 id="32-%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E5%99%A8ssactioner">3.2 命令解析器SSActioner</h3>
<p>命令解析器SSActioner模块的主要结构如下图所示：</p>
<p><img src="./images/SS_Structure_CMDParser.png" alt="CMD_Parser"></p>
<p>本文借助工具Antlr4实现命令编译前端的实现，设计命令的抽象语法，并借助Antlr4工具实现了命令词法分析器和语法分析器的生成，并得到抽象语法树，基于抽象语法树，实现命令操作。</p>
<h4 id="321-%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF">3.2.1 编译前端</h4>
<p>Antlr4工具pom.xml配置如下：</p>
<pre class="hljs"><code><div>        &lt;!-- https://mvnrepository.com/artifact/org.antlr/antlr4 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.antlr&lt;/groupId&gt;
            &lt;artifactId&gt;antlr4&lt;/artifactId&gt;
            &lt;version&gt;4.8-1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- https://mvnrepository.com/artifact/org.antlr/antlr4-runtime --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.antlr&lt;/groupId&gt;
            &lt;artifactId&gt;antlr4-runtime&lt;/artifactId&gt;
            &lt;version&gt;4.8-1&lt;/version&gt;
        &lt;/dependency&gt;
</div></code></pre>
<p>对命令进行分析，获得抽象语法，并使用bnf进行表示，为了便于介绍，将本文使用的命令成为ss语言，ss语法详细介绍如下。</p>
<pre class="hljs"><code><div>//首先，ss语言由很多条命令组成，每条命令以分号';'结尾。(SEMICOLON表示分号';')
ss : (query_list SEMICOLON)*;

//其次，命令由简单命令(simple_query)和带有and/or操作符(operator)的复合命令组成。
query_list : simple_query (operator query_list)*;

/*简单命令主要包含相等(equal_query)，
不相等(not_equal_query)，
大小写不敏感的相等(case_insensitive_equal_query)，
包含(contain_query)四种命令。
每个命令都是二元运算符，
并且第一个参数为行号(COLUMN_ID)或者全部(ALL_COLUMNS)。*/
simple_query :(COLUMN_ID | ALL_COLUMNS)
     ( equal_query
     | not_equal_query
     | case_insensitive_equal_query
     | contain_query );

//题目要求操作符 and，or。
operator : AND | OR;

//相等(equal_query): 命令格式为:COLUMN_ID/ALL_COLUMNS == STRING。STRING表示任意字符串。
equal_query :  EQUAL STRING;

//不相等(equal_query): 命令格式为：COLUMN_ID/ALL_COLUMNS != STRING。
not_equal_query : NOT_EQUAL STRING;

//大小写敏感的相等(case_insensitive_equal_query ):命令格式为：COLUMN_ID/ALL_COLUMNS $= STRING。
case_insensitive_equal_query : CASE_EQUAL STRING;

//包含(contain_query):命令格式为COLUMN_ID/ALL_COLUMNS &amp;= STRING。
contain_query : CONTAIN STRING;
</div></code></pre>
<p><strong>完整代码将在附录2中给出，代码对应位置</strong><code>ServerS\src\main\java\cn\edu\nuaa\little1\grammer\SS.g4</code></p>
<h4 id="322-%E7%BC%96%E8%AF%91%E5%90%8E%E7%AB%AF">3.2.2 编译后端</h4>
<p>通过Antlr4的帮助，获取抽象语法树。为命令创建对应的数据结构。由于时间比较仓促，创建了一个较为简单中间结构。主要分为两层，顶层抽象和底层实现。</p>
<p>顶层抽象主要包括一个接口和两个抽象类(<code>Item</code>，<code>Operator</code>和<code>Query</code>)。</p>
<pre class="hljs"><code><div>//Item顶层抽象接口，命令的中间数据结构使用的类都实现这个接口。
public interface Item {
    public Object execute(Object input);
}

//操作符抽象类：用来执行命令中and / or实现的操作。
public abstract class Operator implements Item {
    ......
    public abstract List&lt;String&gt; opExecute(List&lt;String&gt; columns1,List&lt;String&gt; columns2);
    ......
}

//命令抽象类：四种命令将继承这个抽象类。
public abstract class Query implements Item {
    protected Column column;
    protected Content content;
    ......
}
</div></code></pre>
<p><code>Item</code>的子类主要负责组成一个命令的基本元素，主要包括列(<code>Column</code>)，查询内容(<code>Content</code>)。</p>
<pre class="hljs"><code><div>//列：主要用来保存命令操作的csv文件列号。
public class Column implements Item {
    private String ID; //列号
    ......
}  

//查询内容：主要用来保存命令查询的字符串
public class Content implements Item {
    private String content; //查询内容
    ......
}

</div></code></pre>
<p><code>Operator</code>的子类主要负责and和or操作符的具体实现。</p>
<pre class="hljs"><code><div>//And操作符，主要负责将两次简单命令的结果进行and运算。
public class AndOperator extends Operator {
    @Override
    public List&lt;String&gt; opExecute(List&lt;String&gt; columns1, List&lt;String&gt; columns2) {
        ......
    }
}
//Or操作符，主要负责将两次简单命令的结果进行or运算
public class OrOperator extends Operator {
    @Override
    public List&lt;String&gt; opExecute(List&lt;String&gt; columns1, List&lt;String&gt; columns2) {
        ......
    }
}
</div></code></pre>
<p><code>Query</code>的子类主要负责四种简单命令的实现。</p>
<pre class="hljs"><code><div>//等于命令
public class EqualQuery extends Query {
    @Override
    public List&lt;String&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {
    ......
    }
}
不等于命令NotEqualQuery，
大小写敏感的等于命令CaseEqualQuery，
包含命令ContainQuery的类结构与上述相同。
</div></code></pre>
<p>编译后端主要是由<code>Item</code>，<code>Operator</code>和<code>Query</code>以及各自的子类组成。<br>
<strong>上面只给出部分代码，详细代码见附录3，代码对应位置</strong><code>ServerS\src\main\java\cn\edu\nuaa\little1\query</code></p>
<h4 id="323-%E9%81%8D%E5%8E%86%E8%AF%AD%E6%B3%95%E6%A0%91">3.2.3 遍历语法树</h4>
<p>3.2.1节通过Antlr4获得输入命令的语法树，3.2.2介绍了用来保存命令相关信息的中间数据结构。本节将介绍遍历语法树并从语法树取出命令的相关信息保存到中间数据结构中的过程。</p>
<p>以命令`C1 == &quot;A&quot; or C2 &amp;= &quot;B&quot;为例，语法树的结构如下：</p>
<p><img src="./images/AST.PNG" alt="AST"></p>
<p>通过深度优先，遍历语法树，并在各个结点获取对应命令信息。图中1标记处为起点2标记处为终点。</p>
<p><img src="./images/AST1.PNG" alt="AST1"></p>
<p>图中，每个节点对应“进入节点”和“离开节点”两个箭头。</p>
<p>两个箭头对应到遍历语法树的操作中为<code>enter...</code>和<code>exit...</code>两个接口。以节点<code>simple_query</code>为例。</p>
<pre class="hljs"><code><div>//进入simple_query节点箭头
 @Override
    public void enterSimple_query(SSParser.Simple_queryContext ctx) {
    //实现进入该节点时的操作
     ......
    }

//离开simple_query节点箭头
@Override
    public void exitSimple_query(SSParser.Simple_queryContext ctx) {
    //实现离开该节点时的操作
     ......
    }
</div></code></pre>
<p><strong>上面只给出部分代码，详细代码见附录4，代码对应位置</strong><code>ServerS\src\main\java\cn\edu\nuaa\little1\walker\SSActioner.java</code></p>
<h3 id="33-%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E5%99%A8querymanager">3.3 查询命令管理器QueryManager</h3>
<p>ServerS工具的主要输出是符合条件的CSV行，因此，本文在中间计算的过程中使用行号<code>row_id</code>作为不同计算过程中的传递参数。查询命令管理器QueryManager根据行号将对应行的内容返回。查询命令管理器QueryManager的主要输入为<code>命令实例</code>,<code>命令实例</code>主要分为<code>简单命令(Simple Cmd, SC)</code>和<code>命令操作符(AND / OR)</code>两类。<code>查询命令管理器 QueryManager</code>的主要结构如下图所示：</p>
<!-- 计算过程草图图下(没有时间了，详细过程后续会在Github上进行更新)：   -->
<p><img src="./images/SS_Structure_QueryManager.png" alt="QueryManager"></p>
<p>计算算法的步骤如下：</p>
<ul>
<li>
<p>首先，通过命令解析器获取用户输入<code>文本命令</code>，并将<code>文本命令</code>封装为<code>命令实例</code>，将<code>命令实例</code>保存在<code>命令实例队列</code>中。</p>
</li>
<li>
<p>队列不为空，循环出队，如果出队的是<code>简单命令</code>，不是<code>命令操作AND / OR</code>。就将<code>简单命令</code>执行，并将执行结果入栈。</p>
</li>
<li>
<p>如果是<code>命令操作AND / OR</code>，就进行一次出栈操作和一次出队操作，并将出队的命令执行，得到<code>执行结果</code>,并与出栈的<code>执行结果</code>根据操作符进行AND或者OR操作。并将最终操作结果入栈。</p>
</li>
<li>
<p>当队列为空时，将栈中全部结果出栈，并输出。</p>
</li>
</ul>
<p><strong>详细代码见附录6，代码对应位置。</strong><code>ServerS\src\main\java\cn\edu\nuaa\little1\query\QueryManager.java</code></p>
<h3 id="34-%E6%93%8D%E4%BD%9Ccsv%E6%96%87%E4%BB%B6">3.4 操作CSV文件</h3>
<p>本文通过java工具<code>opencsv</code>将进行csv文件的读取。</p>
<p>工具pom.xml配置。</p>
<pre class="hljs"><code><div> &lt;!-- https://mvnrepository.com/artifact/com.opencsv/opencsv --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.opencsv&lt;/groupId&gt;
            &lt;artifactId&gt;opencsv&lt;/artifactId&gt;
            &lt;version&gt;5.2&lt;/version&gt;
        &lt;/dependency&gt;
</div></code></pre>
<h4 id="331-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%BB%E5%8F%96">3.3.1 文件内容读取</h4>
<p>通过工具读取CSV文件，并将文件内容保存在二维list中，这一部分代码仅仅是使用API，通过<code>opencsv</code>将文件内容读取出来，并保存在一个<code>java list</code>中，<code>list</code>中的主要成员为<code>String</code>类型的<code>array</code>。<code>简单命令实例</code>的主要内容，包括<code>要查询的列ID</code>，<code>查询操作</code>，<code>查询过程使用的关键字</code>。<code>行ID</code>对应<code>list</code>中每个数组的<code>第0个元素</code>，通过java字符串接口<code>equals</code>比较即可找出查询操作对应的列。<code>查询操作</code>主要分为<code>等于(==)</code>，<code>大小写不敏感的等于($=)</code>，<code>不等于(!=)</code>和<code>包含(contains)</code>四类，分别对应java字符串接口中的<code>equals</code>,<code>equalsIgnoreCase</code>,<code>!equals</code>和<code>contains</code>。查询关键字<code>key</code>作为上述四个接口的传入参数。主要结构如下图所示：</p>
<p><img src="./images/SS_Structure_FileHandler.png" alt="FileHandler"></p>
<p><strong>详细代码见附录5，代码对应位置。</strong><code>ServerS\src\main\java\cn\edu\nuaa\little1\file\CSVFileHandler.java</code></p>
<h2 id="4%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">4.运行测试</h2>
<p>由于业务能力有限，未能在规定时间内进行完整的测试过程，只是用了小部分测试用例，保证题目要求的基本流程正常进行。测试通过的测试用例如下：</p>
<p>CSV文件：</p>
<pre class="hljs"><code><div>用例1：题目用例
C1,C2,C3,C1
A,Another “Sample”,Value 1,DD
Sample Text 2,Another “Sample” 2,Value 2,C1

用例2：编写用例
C1,c1,sample,name,ID,89iu
A1,a1,&quot;string&quot;,&quot;String&quot;,88,&quot;I like eating fish&quot;
&quot;string&quot;,B3,B4,aa55,“电脑”，“游泳”
&quot;string&quot;,&quot;string&quot;,,,DDDD

</div></code></pre>
<p>测试命令与运行结果,一共10条命令，这里展示3条。
<strong>其他命令测试用例所在位置。</strong><code>ServerS\src\main\resources</code></p>
<pre class="hljs"><code><div>C1 == &quot;A&quot; or C2 &amp;= &quot;B&quot;
</div></code></pre>
<pre class="hljs"><code><div>C1 == &quot;Test&quot; and * $= &quot;Prod&quot; and * != &quot;Hidden&quot;
</div></code></pre>
<pre class="hljs"><code><div>C1 &amp;= &quot;string&quot; or * $= &quot;Prod&quot; or * != &quot;Hidden&quot;;
</div></code></pre>
<p>运行结果</p>
<pre class="hljs"><code><div>C1 == &quot;A&quot; or C2 &amp;= &quot;B&quot;
//使用用例1 csv文件，没有符合条件的命令
[]
</div></code></pre>
<pre class="hljs"><code><div>C1 == &quot;Test&quot; and * $= &quot;Prod&quot; and * != &quot;Hidden&quot;
//使用用例1 csv文件，没有符合条件的命令
[]
</div></code></pre>
<pre class="hljs"><code><div>C1 &amp;= &quot;string&quot; or * $= &quot;Prod&quot; or * != &quot;Hidden&quot;;
//使用用例2 csv文件，两行数据符合命令
[C1, c1, sample, name, ID, 89iu]
[string, B3, B4, aa55, “电脑”，“游泳”]
[string, string, , , DDDD]
</div></code></pre>
<h2 id="5%E6%80%BB%E7%BB%93">5.总结</h2>
<p>由于业务能力有限，未能在规定时间内开发出可上线的完整版本，提交版ServerS中完成了题目要求的主要流程，即通过HTTP服务获取命令，解析命令，操作CSV文件，将CSV文件操作结果通过HTTP命令返回。由于工具没有经过完整的审查与测试过程，仍然存在很多问题，主要问题如下：</p>
<ul>
<li>
<p>关于CSV文件中的引号问题，由于使用java工具openCSV，openCSV不支持引号的直接读取，在使用的CSV文件中包含引号可能会出现问题。后续工作希望通过Antlr4开发，由于时间限制，没有完成。</p>
</li>
<li>
<p>关于Anltr4解析CSV的语法已经写完，文件位置<code>ServerS\src\main\java\cn\edu\nuaa\little1\grammer\CS</code>。</p>
</li>
<li>
<p>对软件测试过程不够，仍然存在很多问题，没有发现。</p>
</li>
<li>
<p>命令解析过程的错误信息目前只能在HTTP服务端输出，没有生成对应的日志文件。由于时间问题没顾上添加日志管理。</p>
</li>
</ul>
<h2 id="6%E9%99%84%E5%BD%95">6.附录</h2>
<h3 id="%E9%99%84%E5%BD%95-1">附录 1</h3>
<p>HttpServer</p>
<pre class="hljs"><code><div>public class HttpServer {

    public static final String path=&quot;项目所在位置\\ServerS\\src\\main\\resources\\test1.csv&quot;;
    public static void main(String[] args) {
        try {
            //1.建立一个服务器Socket(ServerSocket)绑定指定端口
            ServerSocket serverSocket=new ServerSocket(8800);
            //2.使用accept()方法阻止等待监听，获得新连接
            Socket socket=serverSocket.accept();
            //3.获得输入流
            InputStream is=socket.getInputStream();
            BufferedReader br=new BufferedReader(new InputStreamReader(is));
            //获得输出流
            OutputStream os=socket.getOutputStream();
            PrintWriter pw=new PrintWriter(os);
            //4.读取用户输入信息
            String cmd=null;
            String reply=&quot;&quot;;
            while(!((cmd=br.readLine())==null)){
                System.out.println(&quot;接受命令:&quot;+cmd);
                reply=ServerS.parse(path,cmd);
            }
            //给客户一个响应
            pw.write(reply);
            pw.flush();
            //5.关闭资源
            pw.close();
            os.close();
            br.close();
            is.close();
            socket.close();
            serverSocket.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</div></code></pre>
<h3 id="%E9%99%84%E5%BD%95-2">附录 2</h3>
<p>SS语言语法 SS.g4</p>
<pre class="hljs"><code><div>grammar SS;

//语法规则

ss : (query_list SEMICOLON)*;

query_list : simple_query (operator query_list)*
            | LEFT_BRACKETS simple_query (operator query_list)* RIGHT_BRACKETS
            ;

simple_query :(COLUMN_ID | ALL_COLUMNS)
     ( equal_query
     | not_equal_query
     | case_insensitive_equal_query
     | contain_query );

operator : AND | OR;

equal_query :  EQUAL STRING  ;

not_equal_query : NOT_EQUAL STRING;

case_insensitive_equal_query : CASE_EQUAL STRING;

contain_query : CONTAIN STRING;

//词法规则
AND : 'and';
OR : 'or';

LEFT_BRACKETS : '(';
RIGHT_BRACKETS : ')';

EQUAL : '==';
NOT_EQUAL : '!=';
CASE_EQUAL : '$=';
CONTAIN : '&amp;=';
SEMICOLON : ';';
QUOTATION : '&quot;';

WS : [ \t\n\r] -&gt; skip;
COMMENT : '#' .*? '\n' -&gt; skip;

STRING :QUOTATION (ESC|.)*? QUOTATION;
//匹配两个引号间的任意文本,并且定义转移字符\&quot;和\\
fragment ESC : '\\' [btnr&quot;\\];

//这个ID一定得放在关键字后面
COLUMN_ID : [a-zA-Z0-9]+;
ALL_COLUMNS : '*';


</div></code></pre>
<h3 id="%E9%99%84%E5%BD%95-3">附录 3</h3>
<p>Item</p>
<pre class="hljs"><code><div>public interface Item {
    public Object execute(Object input);
}
</div></code></pre>
<p>Item 实现类Column,Content</p>
<pre class="hljs"><code><div>public class Column implements Item {
    private String ID;
    public String getID(){
        return ID;
    }
    public void setID(String id){
        this.ID=id;
    }

    @Override
    public String execute(Object input) {
     return null;
    }

}

public class Content implements Item {
    private String content;

    public void setContent(String conIn){
        this.content=conIn;
    }

    @Override
    public String execute(Object input) {
        return this.content;
    }

}
</div></code></pre>
<p>Operator</p>
<pre class="hljs"><code><div>public abstract class Operator implements Item {
    @Override
    public List&lt;List&lt;String&gt;&gt; execute(Object input) {
        return operatorExecute(null);
    }

    public abstract List&lt;String&gt; opExecute(List&lt;String&gt; columns1,List&lt;String&gt; columns2);

    public abstract List&lt;List&lt;String&gt;&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns);

}
</div></code></pre>
<p>Operator子类AndOperator, OrOperator</p>
<pre class="hljs"><code><div>public class AndOperator extends Operator {
    @Override
    public List&lt;String&gt; opExecute(List&lt;String&gt; columns1, List&lt;String&gt; columns2) {
        List&lt;String&gt; result=new ArrayList&lt;&gt;();

        result=columns1.stream().filter(s -&gt; columns2.contains(s)).collect(Collectors.toList());
        return result;
    }

    @Override
    public List&lt;List&lt;String&gt;&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {
       return null;
    }
}

public class OrOperator extends Operator {
    @Override
    public List&lt;String&gt; opExecute(List&lt;String&gt; columns1, List&lt;String&gt; columns2) {
        List&lt;String&gt; result=new ArrayList&lt;&gt;();

        result.addAll(columns1);

        for (String column2:columns2) {
                if((!SetUtils.judgeContainsStr(column2))&amp;&amp;(!result.contains(column2))){
                    result.add(column2);
                }
        }

        return result;
    }

    @Override
    public List&lt;List&lt;String&gt;&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {
       return null;
    }

}

</div></code></pre>
<p>Query</p>
<pre class="hljs"><code><div>public abstract class Query implements Item {
    protected Column column;
    protected Content content;

    public Query(){
        content=new Content();
        column=new Column();
    }
    @Override
    public List&lt;String&gt; execute(Object input) {
        FileHandler file = (FileHandler) input;
        return operatorExecute(file.getColumnByHeader(column.getID()));
    }

    public void setID(String id){
        column.setID(id);
    }

    public void setContent(String contin){
        content.setContent(contin);
    }
    public abstract List&lt;String&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns);

}

</div></code></pre>
<p>Query 子类EqualQuery,NotEqualQuery,CaseEqualQuery,ContainQuery</p>
<pre class="hljs"><code><div>public class EqualQuery extends Query {
    @Override
    public List&lt;String&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {
        List&lt;String&gt; result=new ArrayList&lt;String&gt;();

        for (List&lt;String&gt; column:columns) {
            List&lt;String&gt; tmp=new ArrayList&lt;String&gt;();
            tmp.add(column.get(0));
            for (int i=1;i&lt;column.size();i++) {
                if ((!result.contains(String.valueOf(i)))&amp;&amp;content.execute(null).equals(column.get(i))) {
                    result.add(String.valueOf(i));
                }
            }
        }
        return result;
    }
}

public class NotEqualQuery extends Query {
    @Override
    public List&lt;String&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {
        List&lt;String&gt; result=new ArrayList&lt;String&gt;();

        for (List&lt;String&gt; column:columns) {
            List&lt;String&gt; tmp=new ArrayList&lt;String&gt;();
            tmp.add(column.get(0));
            for (int i=1;i&lt;column.size();i++) {
                if ((!result.contains(String.valueOf(i)))&amp;&amp;!content.execute(null).equals(column.get(i))) {
                    result.add(String.valueOf(i));
                }
            }
        }
        return result;
    }
}

public class CaseEqualQuery extends Query {
    @Override
    public List&lt;String&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {
        List&lt;String&gt; result=new ArrayList&lt;String&gt;();

        for (List&lt;String&gt; column:columns) {
            List&lt;String&gt; tmp=new ArrayList&lt;String&gt;();
            tmp.add(column.get(0));
            for (int i=1;i&lt;column.size();i++) {
                if ((!result.contains(String.valueOf(i)))&amp;&amp;content.execute(null).equalsIgnoreCase(&quot;\&quot;&quot;+column.get(i)+&quot;\&quot;&quot;)) {
                    result.add(String.valueOf(i));
                }
            }
        }
        return result;
    }
}

public class ContainQuery extends Query {
    @Override
    public List&lt;String&gt; operatorExecute(List&lt;List&lt;String&gt;&gt; columns) {

        List&lt;String&gt; result=new ArrayList&lt;String&gt;();

        for (List&lt;String&gt; column:columns) {
            List&lt;String&gt; tmp=new ArrayList&lt;String&gt;();
            tmp.add(column.get(0));
            for (int i=1;i&lt;column.size();i++) {
                if ((!result.contains(String.valueOf(i)))&amp;&amp;column.get(i).contains(content.execute(null))) {
                    result.add(String.valueOf(i));
                }
            }

        }
        return result;
    }
}
</div></code></pre>
<h3 id="%E9%99%84%E5%BD%95-4">附录 4</h3>
<p>SSActioner</p>
<pre class="hljs"><code><div>public class SSActioner extends SSBaseListener {
    @Override
    public void enterSimple_query(SSParser.Simple_queryContext ctx) {
        super.exitSimple_query(ctx);
        String ID=null;
        String allID=null;
        if(ctx.COLUMN_ID()!=null) {
            ID = ctx.COLUMN_ID().getText();
        }
        if(ctx.ALL_COLUMNS()!=null) {
            allID = ctx.ALL_COLUMNS().getText();
        }
        if(ID!=null) QueryManager.getManager().addID(ID);
        if(allID!=null) QueryManager.getManager().addID(allID);
//        System.out.println(ID+&quot;:&quot;+allID);
    }

    private String tmpID=&quot;&quot;;

    @Override
    public void enterEqual_query(SSParser.Equal_queryContext ctx) {
        super.enterEqual_query(ctx);
        EqualQuery eq =new EqualQuery();
        SSParser.Simple_queryContext sct= (SSParser.Simple_queryContext) ctx.parent;

        if(ctx.STRING()!=null) {
            int length=ctx.STRING().getText().length()-1;
            eq.setContent(ctx.STRING().getText().substring(1,length));
            eq.setID(getID(sct));
        }
        QueryManager.getManager().addCmd(eq);
    }
    private String getID(SSParser.Simple_queryContext sct){
        String ID=null;
        String allID=null;
        if(sct.COLUMN_ID()!=null) {
            ID = sct.COLUMN_ID().getText();
        }
        if(sct.ALL_COLUMNS()!=null) {
            allID = sct.ALL_COLUMNS().getText();
        }
        if(ID!=null) return ID;
        if(allID!=null) return allID;
        return null;
    }

    @Override
    public void enterNot_equal_query(SSParser.Not_equal_queryContext ctx) {
        super.enterNot_equal_query(ctx);
        NotEqualQuery neq =new NotEqualQuery();
        SSParser.Simple_queryContext sct= (SSParser.Simple_queryContext) ctx.parent;

        if(ctx.STRING()!=null) {
            int length=ctx.STRING().getText().length()-1;
            neq.setContent(ctx.STRING().getText().substring(1,length));
            neq.setID(getID(sct));
        }
        QueryManager.getManager().addCmd(neq);
    }

    @Override
    public void enterCase_insensitive_equal_query(SSParser.Case_insensitive_equal_queryContext ctx) {
        super.enterCase_insensitive_equal_query(ctx);
        CaseEqualQuery ceq =new CaseEqualQuery();
        SSParser.Simple_queryContext sct= (SSParser.Simple_queryContext) ctx.parent;

        if(ctx.STRING()!=null) {
            int length=ctx.STRING().getText().length()-1;
            ceq.setContent(ctx.STRING().getText().substring(1,length));
            ceq.setID(getID(sct));
        }
        QueryManager.getManager().addCmd(ceq);
    }

    @Override
    public void enterContain_query(SSParser.Contain_queryContext ctx) {
        super.enterContain_query(ctx);
        ContainQuery cq =new ContainQuery();
        SSParser.Simple_queryContext sct= (SSParser.Simple_queryContext) ctx.parent;

        if(ctx.STRING()!=null) {
            int length=ctx.STRING().getText().length()-1;

            cq.setContent(ctx.STRING().getText().substring(1,length));
            cq.setID(getID(sct));
        }
        QueryManager.getManager().addCmd(cq);
    }

    @Override
    public void enterOperator(SSParser.OperatorContext ctx) {
        super.enterOperator(ctx);
        Operator op=null;
        if(ctx.AND()!=null){
           op=new AndOperator();
           QueryManager.getManager().addCmd(op);
        }
        if(ctx.OR()!=null){
            op=new OrOperator();
            QueryManager.getManager().addCmd(op);
        }
    }
}

</div></code></pre>
<h3 id="%E9%99%84%E5%BD%95-5">附录 5</h3>
<p>CSVFileHandler</p>
<pre class="hljs"><code><div>public class CSVFileHandler implements FileHandler{

    private static FileHandler csvFileHandler = null;
    private CSVFileHandler(){ }
    public static FileHandler getCSVHandler(){
        if(csvFileHandler==null){
            csvFileHandler=new CSVFileHandler();
        }
        return csvFileHandler;
    }

    private List&lt;String[]&gt; csvContent = new ArrayList&lt;String[]&gt;();
    public List&lt;String[]&gt; read(String srcPath) {

        String charset = &quot;utf-8&quot;;
        Iterator&lt;String[]&gt; iterator=null;
        try (CSVReader csvReader = new CSVReaderBuilder(new BufferedReader(new InputStreamReader(new FileInputStream(new File(srcPath)), charset))).build()) {
            iterator = csvReader.iterator();
            while (iterator.hasNext()) {
                csvContent.add(iterator.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return csvContent;
    }

    public List&lt;List&lt;String&gt;&gt; getColumnByHeader(String header){
        List&lt;List&lt;String&gt;&gt; result =new ArrayList&lt;List&lt;String&gt;&gt;();

        for (int i=0;i&lt;csvContent.get(0).length;i++){
            List&lt;String&gt; temp =new ArrayList&lt;String&gt;();
            if(csvContent.get(0)[i].equals(header)){
                for (String[] column : csvContent) {
                    temp.add(column[i]);
                }
                result.add(temp);
            }
        }
        return result;
    }

}

</div></code></pre>
<h3 id="%E9%99%84%E5%BD%95-6">附录 6</h3>
<p>QueryManager</p>
<pre class="hljs"><code><div>public class QueryManager {
    private static QueryManager Query_Manager=null;
    private QueryManager(Log logIn){
        allInputCommands = new LinkedList&lt;Item&gt;();;
        allColumnID = new ArrayList&lt;String&gt;();
        resultsStk = new Stack&lt;List&lt;String&gt;&gt;();
        log=logIn;
    }

    public static QueryManager getManager(){
        if(Query_Manager==null){
            Query_Manager=new QueryManager(new CmdLog());
        }
        return Query_Manager;
    }
    protected List&lt;String&gt; allColumnID = null;
    protected Queue&lt;Item&gt; allInputCommands = null;
    protected Stack &lt;List&lt;String&gt;&gt; resultsStk = null;

    protected Log log=null;

    public void setLog(Log logIn){
        log=logIn;
    }

    public void addCmd(Item item){
        this.allInputCommands.offer(item);
    }

    public void addID(String ID){
        this.allColumnID.add(ID);
    }

    public List&lt;String&gt; executeAllCmds(){
        List&lt;String&gt; result=null;
        while(!allInputCommands.isEmpty()){
            Item i = allInputCommands.poll();
            result = (List&lt;String&gt;) i.execute(CSVFileHandler.getCSVHandler());
            if(result!=null){
                resultsStk.push(result);
            }else{
                List&lt;String&gt; p1 = resultsStk.pop();
                Item i1=allInputCommands.poll();
                List&lt;String&gt; p2 = (List&lt;String&gt;) i1.execute(CSVFileHandler.getCSVHandler());
                Operator tmpOp= (Operator) i;
                resultsStk.push(tmpOp.opExecute(p1,p2));
            }
        }

        result=new ArrayList&lt;&gt;();
        while(!resultsStk.empty()){
            List&lt;String&gt; tmps=resultsStk.pop();
            for (String tmp:tmps) {
                if(!result.contains(tmp)){
                    result.add(tmp);
                }
            }
        }
        return result;
    }
}

</div></code></pre>

</body>
</html>
